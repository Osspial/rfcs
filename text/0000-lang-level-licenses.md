- Feature Name: lang_level_licenses
- Start Date: (fill me in with today's date, YYYY-MM-DD)
- RFC PR: [rust-lang/rfcs#0000](https://github.com/rust-lang/rfcs/pull/0000)
- Rust Issue: [rust-lang/rust#0000](https://github.com/rust-lang/rust/issues/0000)

# Summary
[summary]: #summary

- Add two new macros:
    + `licenses!()`: a human-readable list of all in-project and upstream licenses.
    + `licenses_json!()`: a JSON-formatted list of all in-project and upstream licenses.
- Add to the `rustc` CLI:
    + `rustc --emit licenses`: emit the human-readable license list as part of the compiler output
    + `rustc --emit licenses-json`: emit the JSON-formatted license list as part of the compiler output
    + `rustc --licenses PATH`: path to a JSON-formatted list of the licenses used by user-compiled code
- Add to `cargo`
    + `cargo licenses --format FMT   Licenses format: human,json [default: human]` Prints the license information generated by rustc to `stdout`
    + `[licenses]` section in `Cargo.toml`: configure how Cargo generates the license list passed to `rustc`

# Motivation
[motivation]: #motivation

Every single piece of code in the Rust ecosystem, from a simple "Hello, World" example to a complex application with hundreds of dependencies through Cargo, depends on licensed open-source software. At the lowest level, projects are going to depend on `libcore` (dual-licensed under the MIT and Apache licenses) and `libstd` (`libcore`'s licenses, and assorted licenses from `libstd`'s Cargo dependencies), and most real-world binaries directly and transitively depend on tens or hundreds of libraries from Crates.io. The vast majority of that code is made available under licenses that require attribution to the authors and/or reproduction of the appropriate license notice. Manually compiling and maintaining that information is out of the question for pretty much all users.

To my knowledge, there is no tooling that automatically generates the appropriate upstream license file. As a result, I been unable to find a *single Rust project* that appropriately complies with all of its upstream license agreements. This includes:

- Servo
- Ripgrep
- Rustup
- Rustc (includes licenses for C dependencies, but not Rust dependencies)
- Cargo (has LICENSE-THIRD-PARTY file that has not been updated with new dependencies since 2014).

Getting this right is really important, but barely anyone bothers since it's such a massive undertaking. As such, the standard Rust tooling should include tools that Just Do The Right Thing, so that Rust projects can be fearlessly legally compliant.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

The standard Rust distribution provides tooling to help automatically manage upstream licenses. At a high level, the tooling can be split into two categories: license *specification* and license *retrieval*.

## License Specification

## In Rustc

`rustc --licenses PATH` is the lowest-level brick in the rust licensing toolchain. It takes a path to a JSON-formatted map between licenses, license text, and libraries. This flag is only valid for `crate-type`s that produce a binary file intended for redistribution (`bin`, `dylib`, `staticlib`, and `cdylib`). Other crate types will use the `--licenses` file specified by the nearest parent crate that accepts the `--licenses` flag. Attempting to pass the `--licenses` flag on an invalid crate types will result in an error. 

The map is formatted as follows: 

```json
{
    "SPDX License Identifier: Optional Copyright Holder": {
        "libraries": ["library0", "library1", "library2"],
        "text": "License Text"
    }
}
```

As an example, the following block is a licenses file that contains `serde` and `rand`, used under the Apache license, as well as `syn`, `libc`, and `cfg-if`, used under the MIT license.

```json
{
    "Apache-2.0": {
        "libraries": ["serde", "rand"],
        "text": "{apache license text}"
    },
    "MIT: The Rust Project Developers": {
        "libraries": ["libc"],
        "text": "Copyright 2014 The Rust Project Developers\n\nPermission is hereby granted {...the rest of the MIT license}"
    },
    "MIT: Alex Crichton": {
        "libraries": ["cfg-if"],
        "text": "Copyright 2014 Alex Crichton\n\nPermission is hereby granted {...the rest of the MIT license}"
    },
    "MIT": {
        "libraries": ["syn"],
        "text": "Permission is hereby granted {...the rest of the MIT license}"
    }
}
```

Note how the Apache 2.0 section contains two libraries from two different authors, as the Apache license text does not contain the copyright holder's name, while there are three different MIT sections:
- One [for `libc`](https://github.com/rust-lang/libc/blob/4f11029a68040c90acf771976b019c1ef273a8cd/LICENSE-MIT), under The Rust Project Developers 
- One [for `cfg-if`](https://github.com/alexcrichton/cfg-if/blob/f71bf60f212312faddee7da525fcf47daac66499/LICENSE-MIT), under Alex Crichton
- One [for `syn`](https://github.com/dtolnay/syn/blob/49102f05b3f67f9de3107521080fdbb9f97c00ab/LICENSE-MIT), where the license has no listed copyright holder

Rustc combines this file with a built-in licenses file that includes licenses from Rust's implicit dependencies. For example, if the user were building their crate in a `no-std` context, rustc would combine the user's file with the following file:

```json
{
    "MIT: The Rust Project Developers": {
        "libraries": ["libcore"],
        "text": "Copyright 2014 The Rust Project Developers\n\nPermission is hereby granted {...the rest of the MIT license}"
    }
}
```

Resulting in the following license map (assuming we use the example user-provided license file above):

```json
{
    "Apache-2.0": {
        "libraries": ["serde", "rand"],
        "text": "{apache license text}"
    },
    "MIT: The Rust Project Developers": {
        "libraries": ["libc", "libcore"],
        "text": "Copyright 2014 The Rust Project Developers\n\nPermission is hereby granted {...the rest of the MIT license}"
    },
    "MIT: Alex Crichton": {
        "libraries": ["cfg-if"],
        "text": "Copyright 2014 Alex Crichton\n\nPermission is hereby granted {...the rest of the MIT license}"
    },
    "MIT": {
        "libraries": ["syn"],
        "text": "Permission is hereby granted {...the rest of the MIT license}"
    }
}
```

Rustc then renders the combined file into a human-readable version that can be included in downstream applications. This RFC does not specify how the human-readable version should be formatted.

## In Cargo

The user generally shouldn't have to hand-write the license file. Instead, it gets automatically generated by Cargo based on the crate's dependency tree and passed into rustc through the standard build process.

If a crate is multi-licensed, Cargo will default to using the first license in the multi-license list. However, users can specify a preferred license via the `[licenses]` section in `Cargo.toml`:

```toml
[licenses]
prefer = ["Apache-2.0", "MIT", "Zlib"]
```

If present, Cargo will prefer the earliest matching license in the `prefer` list. Cargo splits the license string into multiple licenses on any of the following patterns:
- `"/"`
- `","`
- `"\bOR\b"`

If a crate has dependencies with licenses Cargo cannot detect (e.g. in FFI crates), it can specify external licenses via the `licenses.external` field, which contains a path to a JSON licenses file relative to the crate's root:

```toml
[licenses]
external = "./THIRD_PARTY_LICENSES.json"
```

Cargo merges the provided license file with its auto-generated license file before passing the file into rustc.

# License Retrieval

Users can access the license data either directly in the source code or through the filesystem with the crate's build artifacts. Both methods are provided so that crate authors can distribute license information as is best suited for their particular application: CLI applications that are distributed via a single binary may want to expose the license information through a command-line option, while applications with more complex distribution methods may want to include the license information as a file that gets distributed alongside the binary.

Two compiler built-in macros are provided to retrieve the license information in the source code:

- `licenses!()`: the human-formatted license information.
- `licenses_json!()`: the json-formatted license information compiled by Rustc.

Both macros return `&'static str`s. The JSON data is exposed so applications can do additional post-processing on the license list.

----

Users can specify `licenses` or `licenses-json` in rustc's `--emit` flag, which outputs the human-readable and JSON-formatted license files to the filesystem.

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

Keys in the map should be formatted as a SPDX license identifier (when available), optionally followed by a colon and the copyright holder's name if the license text is customized to each particular copyright holder. If the license identifier contains a colon, it can be escaped with two consecutive colons (`ANNOYING:IDENTIFIER` -> `ANNOYING::IDENTIFIER`).

TODO WRITE REST OF REFERENCE

This is the technical portion of the RFC. Explain the design in sufficient detail that:

- Its interaction with other features is clear.
- It is reasonably clear how the feature would be implemented.
- Corner cases are dissected by example.

The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.

# Drawbacks
[drawbacks]: #drawbacks

More complexity in the language infrastructure. Most languages don't seem to provide a license management mechanism built into the compiler, but most languages don't make it as easy to add new dependencies as Rust does.

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

- Let the community manage this, and provide a stable way to access the licenses implicitly used by the standard libraries.
- Standardize `Cargo.toml` fields for specifying all necessary license information, and let third-party crates handle compiling that information into a usable form.
- Expose `licenses_json` as a structure rather than a JSON string.

# Prior art
[prior-art]: #prior-art

Discuss prior art, both the good and the bad, in relation to this proposal.
A few examples of what this can include are:

- For language, library, cargo, tools, and compiler proposals: Does this feature exist in other programming languages and what experience have their community had?
- For community proposals: Is this done by some other community and what were their experiences with it?
- For other teams: What lessons can we learn from what other communities have done here?
- Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.

This section is intended to encourage you as an author to think about the lessons from other languages, provide readers of your RFC with a fuller picture.
If there is no prior art, that is fine - your ideas are interesting to us whether they are brand new or if it is an adaptation from other languages.

Note that while precedent set by other languages is some motivation, it does not on its own motivate an RFC.
Please also take into consideration that rust sometimes intentionally diverges from common language features.

# Unresolved questions
[unresolved-questions]: #unresolved-questions

- What parts of the design do you expect to resolve through the RFC process before this gets merged?
- What parts of the design do you expect to resolve through the implementation of this feature before stabilization?
- What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?

# Future possibilities
[future-possibilities]: #future-possibilities

- This RFC has cargo choose the first license in the multi-license list so that it doesn't have to be aware of license semantics. In theory, it could automatically select the most permissive license, for whatever definition of permissive Cargo chooses to accept.
- `[licenses]` could have a disallowed licenses list that warns if a forbidden license is detected.
- Cargo could automatically warn upon license incompatibilities.
